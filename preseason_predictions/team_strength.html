<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Generate Team Quality Metrics</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>Generate Team Quality Metrics</h1>

<p>In order to build a prediction model for next season I need to know how good
each team was in the previous season(s). A decent and simple way to measure
team quality is to use the <a href="http://public.gettysburg.edu/%7Ecwessell/RankingPage/massey.pdf">Massey rankings</a>, which basically just finds the
points above average that each team contributes to the margin of victory of 
each game using <a href="https://en.wikipedia.org/wiki/Ordinary_least_squares">Ordinary Least Squares Regression</a>. We will get into more complicated measures later on in this post. </p>

<p>To do this, for each season, I need to organize the data so that each row 
corresponds to a game. The dependent variable (what we are trying to predict)
is the margin of victory from the view of the home team. The 
independent variables needed will be dummay variables indicating who is home 
(using a + 1) and who is away (using a -1). Normally you wold also include a
dummy variable for neutral site games, however the 2015 season on CFB 
Reference doesn&#39;t list any info on neutral site games. So even though we have
this information for every other season I&#39;m going to have to exclude it since
the overall goal of this project is to predict the coming seasons results, so 
we can&#39;t just ignore we don&#39;t have it for this year.</p>

<p>Let&#39;s get started by reading in the data I&#39;ve pulled from CFB Reference that
includes the results of every FBS football game over the last 10 seasons.</p>

<pre><code class="r">library(readr) 
library(purrr)  
library(dplyr)
library(tidyr)
library(stringr)
library(lubridate)
library(broom)
options(dplyr.width = Inf)

raw_schedule &lt;- read_csv(file = &quot;~/Documents/fb_analysis/Datasets/cfb_schedule_05_15.csv&quot;,
                    col_types = cols(Date = col_date(format = &quot;%b %d, %Y&quot;)))

## Need to add the points for the home and away teams and find what season each
## game belongs to

results &lt;- raw_schedule %&gt;%
  mutate(Home_Points = ifelse(Winner == Home, Winner_Points, Loser_Points),
         Away_Points = ifelse(Winner == Home, Loser_Points, Winner_Points),
         Home_MOV = Home_Points - Away_Points,
         Season = ifelse(month(Date) == 1, year(Date) - 1, year(Date))) %&gt;%
  filter(!is.na(Home_MOV))
</code></pre>

<table><thead>
<tr>
<th align="right">Season</th>
<th align="right">Week</th>
<th align="left">Home</th>
<th align="left">Away</th>
<th align="right">Home_Points</th>
<th align="right">Away_Points</th>
<th align="right">Home_MOV</th>
</tr>
</thead><tbody>
<tr>
<td align="right">2005</td>
<td align="right">1</td>
<td align="left">Arizona State</td>
<td align="left">Temple</td>
<td align="right">63</td>
<td align="right">16</td>
<td align="right">47</td>
</tr>
<tr>
<td align="right">2005</td>
<td align="right">1</td>
<td align="left">Cincinnati</td>
<td align="left">Eastern Michigan</td>
<td align="right">28</td>
<td align="right">26</td>
<td align="right">2</td>
</tr>
<tr>
<td align="right">2005</td>
<td align="right">1</td>
<td align="left">Connecticut</td>
<td align="left">Buffalo</td>
<td align="right">38</td>
<td align="right">0</td>
<td align="right">38</td>
</tr>
<tr>
<td align="right">2005</td>
<td align="right">1</td>
<td align="left">Marshall</td>
<td align="left">William &amp; Mary</td>
<td align="right">36</td>
<td align="right">24</td>
<td align="right">12</td>
</tr>
<tr>
<td align="right">2005</td>
<td align="right">1</td>
<td align="left">Tulsa</td>
<td align="left">Minnesota</td>
<td align="right">10</td>
<td align="right">41</td>
<td align="right">-31</td>
</tr>
<tr>
<td align="right">2005</td>
<td align="right">1</td>
<td align="left">Louisiana-Monroe</td>
<td align="left">Northwestern State</td>
<td align="right">23</td>
<td align="right">27</td>
<td align="right">-4</td>
</tr>
</tbody></table>

<p>Now comes the tricky part. I need to turn this long data frame of game
results into a wide format that includes the team names as variable names.
I&#39;ve written the following helper function to &ldquo;stack&rdquo; the teams in each 
game so that we don&#39;t have to worry about having two team name columns.</p>

<pre><code class="r">organize_game_results &lt;- function(df, ...){
  home_teams &lt;- df %&gt;%
    select(Season, Game_Num, Home, Home_MOV, ...) %&gt;% 
    mutate(involved = 1) %&gt;% 
    rename(Team = Home)
  away_teams &lt;- df %&gt;%
    select(Season, Game_Num, Away, Home_MOV, ...) %&gt;% 
    mutate(involved = -1) %&gt;% 
    rename(Team = Away)
  return(bind_rows(home_teams, away_teams))
}
</code></pre>

<p>I&#39;m going to do a bit of R Kung Fu but here is my basic approach:</p>

<ul>
<li><a href="https://blog.rstudio.org/2016/02/02/tidyr-0-4-0/">&ldquo;Nest&rdquo;</a> the stacked team
data so that the data is grouped by Season. Since each season&#39;s data is just
stored as a list in a column of the data frame we can use <code>purrr</code>&#39;s
<code>map</code> function to apply functions to each season of data seperately.</li>
<li>Use the <code>spread</code> function from the <code>tidyr</code> package to go from a tall to 
wide format</li>
<li>Use a linear regression to calculate the Massey Rankings</li>
<li>Use the <code>tidy</code> function from the <code>broom</code> package to extract the coefficient
values (which are the actual team rankings)</li>
<li>Then unnest each season to get one data frame for our results</li>
</ul>

<pre><code class="r">season_team_values &lt;- results %&gt;%
  organize_game_results %&gt;%
  group_by(Season) %&gt;%
  nest() %&gt;% 
  mutate(regression_df = map(data, spread, Team, involved, fill = 0),
         model = map(regression_df, ~ lm(Home_MOV ~ . - Game_Num, data = .)),
         team_values = map(model, tidy)) %&gt;%
  unnest(team_values) %&gt;%
  mutate(term = str_replace_all(term, fixed(&quot;`&quot;), &quot;&quot;))
</code></pre>

<table><thead>
<tr>
<th align="right">Season</th>
<th align="left">term</th>
<th align="right">estimate</th>
<th align="right">std.error</th>
<th align="right">statistic</th>
<th align="right">p.value</th>
</tr>
</thead><tbody>
<tr>
<td align="right">2005</td>
<td align="left">(Intercept)</td>
<td align="right">3.646571</td>
<td align="right">0.5735598</td>
<td align="right">6.357787</td>
<td align="right">0.0000000</td>
</tr>
<tr>
<td align="right">2005</td>
<td align="left">Air Force</td>
<td align="right">31.465096</td>
<td align="right">15.7468260</td>
<td align="right">1.998187</td>
<td align="right">0.0461865</td>
</tr>
<tr>
<td align="right">2005</td>
<td align="left">Akron</td>
<td align="right">27.347303</td>
<td align="right">15.5560123</td>
<td align="right">1.757989</td>
<td align="right">0.0793035</td>
</tr>
<tr>
<td align="right">2005</td>
<td align="left">Alabama</td>
<td align="right">46.604288</td>
<td align="right">15.6858803</td>
<td align="right">2.971098</td>
<td align="right">0.0030966</td>
</tr>
<tr>
<td align="right">2005</td>
<td align="left">Alabama-Birmingham</td>
<td align="right">30.838248</td>
<td align="right">15.8030438</td>
<td align="right">1.951412</td>
<td align="right">0.0515135</td>
</tr>
<tr>
<td align="right">2005</td>
<td align="left">Appalachian State</td>
<td align="right">22.981138</td>
<td align="right">18.3074848</td>
<td align="right">1.255286</td>
<td align="right">0.2099059</td>
</tr>
</tbody></table>

<p>Hopefully that wasn&#39;t too complicated</p>

<h3>Problems</h3>

<p>If you inspect the results you&#39;ll see that there are some areas where we could
improve our results. Here is a list off the top of my head:</p>

<ol>
<li>We don&#39;t adjust for blowouts at all</li>
<li>We don&#39;t adjust for teams who only play 1 or 2 games all season. For
example, Portland State beat two very bad teams in 2015 but those were their
only games so they are rated as one of the best teams in the country. We 
could just consider all teams who only showed up 1-2 times as one team, sort
of as a placeholder for &ldquo;FCS&rdquo; teams (the lower division of CFB).</li>
<li>We don&#39;t use a penalized regression to regularize our results at all</li>
<li>We don&#39;t include any team priors from the previous season.</li>
</ol>

<p>While I certainly believe all of these areas could help improve our results
I&#39;d like a way to know for sure. Since the goal of this post is to determine
how good each team was in a season we can just test that. If our team ratings
accurately predict the results of games between teams then we can assume that
the ratings reflect the true quality of teams.</p>

<p>What we don&#39;t want to do is use the same underlying games to both generate and
test the accuracy of the team rankings, then we would be rewarding methods that
overfit to the season results and not the true underlying team quality. So we
will have to generate our team rankings and then test their accuracy on 
different sets of games. I&#39;m going to do this using cross validation which is 
a popular way to test the accuracy of models while avoiding overfitting. </p>

<p>Let&#39;s find the accuracy of this base method we have already used. I&#39;m using 
a helper function called <code>safe_pred</code> which you can find in the raw R file I
used to write this post. It basically helps make predictions when a team 
only shows up in the training or test data but not both, which normally
would cause an error. </p>

<pre><code class="r">K &lt;- 4
cv_results &lt;- results %&gt;%
  mutate(fold_id = sample(1:K, size = n(), replace = T)) %&gt;%
  organize_game_results(fold_id) %&gt;% 
  group_by(Season) %&gt;%
  nest() %&gt;% 
  crossing(fold = 1:K) %&gt;% 
  mutate(train = map2(data, fold, function(df, fold_num) filter(df, fold_id != fold_num)),
         test = map2(data, fold, function(df, fold_num) filter(df, fold_id == fold_num)),
         regression_df = map(train, spread, Team, involved, fill = 0),
         test_df = map(test, spread, Team, involved, fill = 0),
         model = map(regression_df, ~ lm(Home_MOV ~ . - Game_Num - fold_id, data = .)),
         preds = map2(model, test_df, safe_pred),
         error = map_dbl(preds, function(df) mean((df$Home_MOV - df$pred)^2))) %&gt;%
  group_by(Season) %&gt;%
  summarize(mean_mse = mean(error), sd_mse = sd(error))

c(mean(cv_results$mean_mse), mean(cv_results$sd_mse))
</code></pre>

<pre><code>## [1] 259.69974  26.38866
</code></pre>

<p>So that&#39;s our baseline Mean Squared Error.  </p>

<p>Let&#39;s try and beat it using the 2nd idea I had. The first is kind of arbitrary
(what do we define as a blowout?) and the fourth we will focus on in the actual
prediction model we are trying to build, so I don&#39;t think it&#39;s needed yet.</p>

<pre><code class="r">game_list &lt;- results %&gt;%
  mutate(fold_id = sample(1:K, size = n(), replace = T)) %&gt;%
  organize_game_results(fold_id)

bad_teams &lt;- game_list %&gt;%
  count(Season, Team) %&gt;%
  mutate(bad_team = n &lt;= 2)

fcs_fix_results &lt;- game_list %&gt;%
  left_join(bad_teams, by = c(&quot;Season&quot;, &quot;Team&quot;)) %&gt;%
  mutate(Team = ifelse(bad_team, &quot;FCS&quot;, Team)) %&gt;%
  select(-n, -bad_team) %&gt;%
  group_by(Season) %&gt;%
  nest() %&gt;% 
  crossing(fold = 1:K) %&gt;% 
  mutate(train = map2(data, fold, function(df, fold_num) filter(df, fold_id != fold_num)),
         test = map2(data, fold, function(df, fold_num) filter(df, fold_id == fold_num)),
         regression_df = map(train, spread, Team, involved, fill = 0),
         test_df = map(test, spread, Team, involved, fill = 0),
         model = map(regression_df, ~ lm(Home_MOV ~ . - Game_Num - fold_id, data = .)),
         preds = map2(model, test_df, safe_pred),
         error = map_dbl(preds, function(df) mean((df$Home_MOV - df$pred)^2))) %&gt;%
  group_by(Season) %&gt;%
  summarize(mean_mse = mean(error), sd_mse = sd(error))

c(mean(fcs_fix_results$mean_mse), mean(fcs_fix_results$sd_mse))
</code></pre>

<pre><code>## [1] 264.72531  24.29716
</code></pre>

<p>Well that wasn&#39;t even an improvement, I guess since by definition those 
teams don&#39;t appear too often it really wouldn&#39;t make that much of a 
difference. What about using a penalized regression like ridge regression
to reduce the size of the coefficients? Once again we are going to need a
helper function to help us accomplish this. </p>

<pre><code class="r">ridge_results &lt;- game_list %&gt;%
  left_join(bad_teams, by = c(&quot;Season&quot;, &quot;Team&quot;)) %&gt;%
  mutate(Team = ifelse(bad_team, &quot;FCS&quot;, Team)) %&gt;%
  select(-n, -bad_team) %&gt;%
  group_by(Season) %&gt;%
  nest() %&gt;% 
  crossing(fold = 1:K) %&gt;% 
  mutate(train = map2(data, fold, function(df, fold_num) filter(df, fold_id != fold_num)),
         test = map2(data, fold, function(df, fold_num) filter(df, fold_id == fold_num)),
         regression_df = map(train, spread, Team, involved, fill = 0),
         test_df = map(test, spread, Team, involved, fill = 0),
         model = map(regression_df, ridge_fit),
         preds = map2(model, test_df, ridge_pred),
         error = map_dbl(preds, function(df) mean((df$Home_MOV - df$pred)^2))) %&gt;%
  group_by(Season) %&gt;%
  summarize(mean_mse = mean(error), sd_mse = sd(error))

c(mean(ridge_results$mean_mse), mean(ridge_results$sd_mse))
</code></pre>

<pre><code>## [1] 514.3699 117.7764
</code></pre>

<p>Wow, that&#39;s way worse than the linear regression results.</p>

<h3>Conclussions</h3>

<p>So there you have it, we&#39;ve shown a way to generate ratings for team quality
in a season and shown that those are about as good as we could do using the
limited data we do have. Also I&#39;m pretty proud of getting that grouped cross
validation code to work using nested data frames and the <code>purrr</code> package. </p>

</body>

</html>
